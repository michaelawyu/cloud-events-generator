# coding: utf-8

from __future__ import absolute_import
from datetime import date, datetime  # noqa: F401
import uuid
import re

from typing import List, Dict  # noqa: F401

from ..base_model import Model
from .. import util

{{#Imports}}
from .{{KlsName}} import {{KlsName}}  # noqa: E501
{{/Imports}}

{{#Model}}
class {{KlsName}}(Model):
    """NOTE: This class is auto generated by Cloud Events Generator
    (https://github.com/michaelawyu/cloud-events-generator)
    using modified templates from OpenAPI generator
    (https://github.com/OpenAPITools/openapi-generator)
    under Apache 2.0 License.

    Do not edit the class manually.
    """

    def __init__(self, bypass_check=False{{#Vars}}, {{Name}}={{#DefaultValue}}{{{DefaultValue}}}{{/DefaultValue}}{{^DefaultValue}}None{{/DefaultValue}}{{/Vars}}):  # noqa: E501
        """{{KlsName}} - a model defined in Cloud Events Generator

        {{#Vars}}
        :param {{Name}}: The {{Name}} of this {{KlsName}}.  # noqa: E501
        :type {{Name}}: {{DataType}}
        {{/Vars}}
        """
        self.openapi_types = {
{{#Vars}}
            '{{Name}}': {{{DataType}}}{{#HasMore}},{{/HasMore}}
{{/Vars}}
        }

        self.attribute_map = {
{{#Vars}}
            '{{Name}}': '{{BaseName}}'{{#HasMore}},{{/HasMore}}
{{/Vars}}
        }
        if not bypass_check:
{{#Vars}}
                self.{{Name}} = {{Name}}
{{/Vars}}
        else:
{{#Vars}}
                self._{{Name}} = {{Name}}
{{/Vars}}

    @classmethod
    def from_dict(cls, dikt) -> '{{KlsName}}':
        """Returns the dict as a model

        :param dikt: A dict.
        :type: dict
        :return: An instance of this {{KlsName}}.  # noqa: E501
        :rtype: {{KlsName}}
        """
        return util.deserialize_model(dikt, cls)        
{{#Vars}}

    @property
    def {{Name}}(self):
        """Gets the {{Name}} of this {{KlsName}}.

        {{{Description}}}  # noqa: E501

        :return: The {{Name}} of this {{KlsName}}.
        :rtype: {{DataType}}
        """
        return self._{{Name}}

    @{{Name}}.setter
    def {{Name}}(self, {{Name}}):
        """Sets the {{Name}} of this {{KlsName}}.

        {{{Description}}}  # noqa: E501

        :param {{Name}}: The {{Name}} of this {{KlsName}}.
        :type {{Name}}: {{DataType}}
        """

{{#Auto}}
{{#IsUUIDv4}}
        if {{Name}} is None:
                self._{{Name}} = str(uuid.uuid4())
        else:
                self._{{Name}} = {{Name}}
{{/IsUUIDv4}}
{{#IsRFC3339}}
        if {{Name}} is None:
                self._{{Name}} = datetime.utcnow().isoformat('T') + 'Z'
{{/IsRFC3339}}
        else:
                self._{{Name}} = {{Name}}
{{/Auto}}
{{^Auto}}
{{#IsEnum}}
        allowed_values = [{{#AllowableValues}}{{{Value}}}{{#HasMore}}, {{/HasMore}}{{/AllowableValues}}]  # noqa: E501
{{#IsContainer}}
{{#IsListContainer}}
        if not set({{{Name}}}).issubset(set(allowed_values)):
            raise ValueError(
                "Invalid values for `{{{Name}}}` [{0}], must be a subset of [{1}]"  # noqa: E501
                .format(", ".join(map(str, set({{{Name}}}) - set(allowed_values))),  # noqa: E501
                        ", ".join(map(str, allowed_values)))
            )
{{/IsListContainer}}
{{/IsContainer}}
{{^IsContainer}}
        if {{{Name}}} not in allowed_values:
            raise ValueError(
                "Invalid value for `{{{Name}}}` ({0}), must be one of {1}"
                .format({{{Name}}}, allowed_values)
            )
{{/IsContainer}}
{{/IsEnum}}
{{^IsEnum}}
{{#Required}}
        if {{Name}} is None:
            raise ValueError("Invalid value for `{{Name}}`, must not be `None`")  # noqa: E501
{{/Required}}
{{#HasValidation}}
{{#MaxLength}}
        if {{Name}} is not None and len({{Name}}) > {{MaxLength}}:
            raise ValueError("Invalid value for `{{Name}}`, length must be less than or equal to `{{MaxLength}}`")  # noqa: E501
{{/MaxLength}}
{{#MinLength}}
        if {{Name}} is not None and len({{Name}}) < {{MinLength}}:
            raise ValueError("Invalid value for `{{Name}}`, length must be greater than or equal to `{{MinLength}}`")  # noqa: E501
{{/MinLength}}
{{#Maximum}}
        if {{Name}} is not None and {{Name}} >{{^ExclusiveMaximum}}={{/ExclusiveMaximum}} {{Maximum}}:  # noqa: E501
            raise ValueError("Invalid value for `{{Name}}`, must be a value less than {{^ExclusiveMaximum}}or equal to {{/ExclusiveMaximum}}`{{Maximum}}`")  # noqa: E501
{{/Maximum}}
{{#Minimum}}
        if {{Name}} is not None and {{Name}} <{{^ExclusiveMinimum}}={{/ExclusiveMinimum}} {{Minimum}}:  # noqa: E501
            raise ValueError("Invalid value for `{{Name}}`, must be a value greater than {{^ExclusiveMinimum}}or equal to {{/ExclusiveMinimum}}`{{Minimum}}`")  # noqa: E501
{{/Minimum}}
{{#Pattern}}
        if {{Name}} is not None and not re.search(r'{{{Pattern}}}', {{Name}}):  # noqa: E501
            raise ValueError("Invalid value for `{{Name}}`, must match pattern `{{{Pattern}}}`")  # noqa: E501
{{/Pattern}}
{{#MaxItems}}
        if {{Name}} is not None and len({{Name}}) > {{MaxItems}}:
            raise ValueError("Invalid value for `{{Name}}`, number of items must be less than or equal to `{{MaxItems}}`")  # noqa: E501
{{/MaxItems}}
{{#MinItems}}
        if {{Name}} is not None and len({{Name}}) < {{MinItems}}:
            raise ValueError("Invalid value for `{{Name}}`, number of items must be greater than or equal to `{{MinItems}}`")  # noqa: E501
{{/MinItems}}
{{/HasValidation}}
{{/IsEnum}}

        self._{{Name}} = {{Name}}

{{/Auto}}
{{/Vars}}
{{/Model}}
